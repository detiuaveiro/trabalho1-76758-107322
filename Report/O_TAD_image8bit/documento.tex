\documentclass{report}
\usepackage[T1]{fontenc} % Fontes T1
\usepackage[utf8]{inputenc} % Input UTF8
\usepackage[backend=biber, style=ieee]{biblatex} % para usar bibliografia
\usepackage{csquotes}
\usepackage[portuguese]{babel} %Usar língua portuguesa
\usepackage{blindtext} % Gerar texto automaticamente
\usepackage[printonlyused]{acronym}
\usepackage{hyperref} % para autoref
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{lmodern}
\usepackage{epigraph} 
\usepackage[export]{adjustbox}
\usepackage{subcaption}
\usepackage{wrapfig}
\usepackage{multirow}
\usepackage{tabularx}
\usepackage{array}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry} 
\usepackage{titlesec}
\usepackage{booktabs}

\titleformat{\chapter}[display]
  {\normalfont\bfseries}{}{0pt}{\Huge}

\geometry{lmargin=2.5cm,rmargin=2.5cm,bmargin=3cm,tmargin=2.5cm} 

\definecolor{codebackground}{rgb}{0.95,0.95,0.92}
\definecolor{codegreen}{rgb}{0,0.75,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.95}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{codestring}{rgb}{0.82,0.1,0.26}
\definecolor{darkgreen}{rgb}{0,0.35,0}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{codebackground},
    commentstyle=\color{codegreen},
    keywordstyle=\color{codepurple},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codestring},
    basicstyle=\ttfamily\small,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    language=C,
    emph={uint8, Image},
    emphstyle=\color{darkgreen}
}

\lstset{style=CStyle}


\bibliography{bibliografia}


\begin{document}
%%
% Definições
%
\def\titulo{O TAD image8bit}
\def\data{\today}
\def\autores{José Diogo Cerqueira, Bernardo Marujo}
\def\autorescontactos{(76758) c.jose.diogo@ua.pt, (107322) bernardomarujo@ua.pt}
\def\departamento{Dept. de Eletrónica, Telecomunicações e Informática}
\def\empresa{Universidade de Aveiro}
\def\logotipo{ua.pdf}
%
%%%%%% CAPA %%%%%%
%

%
%
\begin{titlepage}

\begin{center}
%
\vspace*{50mm}
%
{\Huge\textbf{\titulo}}\\
{\Large \departamento\\ \empresa}\\
%
\vspace{10mm}
%
%
{\LARGE \autores\\ \autorescontactos} \\ 
%
\vspace{10mm}
%
\data
%
\vspace{20mm}
%
\begin{figure}[h]
\center
\includegraphics{\logotipo}
\end{figure}
%
\end{center}
%
\end{titlepage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagenumbering{roman}


\tableofcontents



\clearpage
\pagenumbering{arabic}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introdução}

Neste relatório é apresentado o trabalho prático realizado no âmbito da unidade curricular de Algoritmos e Estruturas de Dados, com dois objetivos principais.
\par
O primeiro é desenvolver desenvolver e testar o TAD (Tipo Abstrato de Dados) \texttt{image8bit}, que permite manipular imagens de 8 bits com com níveis de cinzento, em que cada pixel pode tomar valores de intensidade entre 0 e 255.
\par
O segundo é analisar a complexidade computacional da função \texttt{ImageLocateSubImage} que permite determinar, caso exista, a localização de uma subimagem numa imagem dada, e da função ImageBlur(…) que aplica um filtro a uma imagem e a torna baça.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Estrutura de Dados e Funções do TAD image8bit}

\section{Estrutura de Dados image8bit}

A estrutura de dados \texttt{image8bit} é composta por um ponteiro para um array de pixeis, um inteiro que representa a largura da imagem, um inteiro que representa a altura da imagem e um inteiro que representa o número de pixeis da imagem.
\par
O array de pixeis é um array de unsigned char, em que cada posição do array representa um pixel da imagem, e cada pixel pode tomar valores de intensidade entre 0 e 255. A posição do pixel (\(x\),\(y\)) no array é dada por \(x\) + \(y\) * (\textit{largura da imagem}).
\par
A estrutura de dados \texttt{image8bit} é definida da seguinte forma:

\begin{lstlisting}[language=C]
struct image {
  int width;
  int height;
  int maxval;   // maximum gray value (pixels with maxval are pure WHITE)
  uint8* pixel; // pixel data (a raster scan)
};
\end{lstlisting}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Apresentação e Análise da Complexidade Computacional das Funções}

\section{Analise da complexidade da função ImageLocateSubImage}
\subsection{Apresentação}

A função \texttt{ImageMatchSubImage} permite determinar, caso exista, a localização de uma subimagem numa imagem dada.
\par
Para determinar a localização da subimagem, a função percorre a imagem dada e, para cada pixel da imagem, verifica se a subimagem se encontra nessa posição. 
Para verificar se a subimagem se encontra nessa posição, a função percorre a subimagem e verifica se os pixeis da subimagem são iguais aos pixeis da imagem na posição (x,y) da imagem.
Por este motivo, podemos fazer a análise da complexidade para cada função.
\par
\begingroup
\begin{lstlisting}[language=C]
int ImageLocateSubImage(Image img1, int* px, int* py, Image img2) { ///
    assert (img1 != NULL);
    assert (img2 != NULL);
    assert (px != NULL);
    assert (py != NULL);
    for (int i = 0; i < img1->height - img2->height; i++) {
        for (int j = 0; j < img1->width - img2->width; j++) {
            if (ImageMatchSubImage(img1, j, i, img2)) {
                *px = j;
                *py = i;
                return 1;
            }
        }
    }
    return 0;
}
\end{lstlisting}
    
\begin{lstlisting}[language=C]
int ImageMatchSubImage(Image img1, int x, int y, Image img2) { ///
  assert (img1 != NULL);
  assert (img2 != NULL);
  assert (ImageValidPos(img1, x, y));
  assert (ImageValidRect(img1, x, y, img2->width, img2->height));
  for (int i = 0; i < img2->height; i++) {
    for (int j = 0; j < img2->width; j++) {
      if (ImageGetPixel(img1, x + j, y + i) != ImageGetPixel(img2, j, i)) {
        return 0;
      }
    }
  }
  return 1;
}
\end{lstlisting}
\endgroup

\subsection{Análise Formal da Complexidade}

\subsubsection*{ImageMatchSubImage}
A função \texttt{ImageMatchSubImage} tem uma complexidade de \(O(h \cdot w)\), pois itera por cada pixel da subimagem, 
sendo \(h\) e \(w\) a altura e largura da subimagem, respetivamente.

\subsubsection{Complexidade da Função ImageLocateSubImage}

\subsubsection{Melhor Caso}
Se a subimagem for encontrada na primeira posição, a função \texttt{ImageMatchSubImage} será chamada apenas uma vez. 
Portanto, a complexidade no melhor caso é \(O(h \cdot w)\), escalando o tempo de execução, linearmente, com o tamanho da subimagem.

\subsubsection{Pior Caso}
No pior caso, os ciclos aninhados iteram sobre todas as posições possíveis dentro da imagem, 
resultando em \((n-h) \cdot (m-w)\) chamadas a \texttt{ImageMatchSubImage}, com \(n\) e \(m\) a altura e largura da imagem, respetivamente. 
Cada chamada a \texttt{ImageMatchSubImage} tem uma complexidade de \(O(h \cdot w)\).
Portanto, a complexidade no pior caso é \(O((n-h) \cdot (m-w) \cdot h \cdot w)\), escalando o tempo de execução, quadraticamente, 
com o tamanho da imagem e da subimagem.

\subsection{Testes Experimentais}




\subsection{Conclusões}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Analise da complexidade da função ImageBlur}

\subsection{Apresentação}
Esta função aplica um filtro a uma imagem e a torna baça, tomando como argumentos a imagem e o tamanho do filtro, dado por \(dx\) e \(dy\).
\par
Para calcular o valor de cada pixel da imagem resultante, a função percorre a imagem e, para cada pixel,
calcula a média dos valores dos pixeis da imagem original que se encontram dentro do filtro. Por forma a reduzir a complexidade computacional,
a função \texttt{ImageBlur} utiliza uma matriz auxiliar \texttt{cumSum} que guarda a soma cumulativa dos pixeis anteriores.
\par
Depois de calculada a matriz auxiliar, aplicamos o filtro calculando a média dos valores dos pixeis da imagem original que se encontram dentro do filtro.
\par
A complexidade da função depende apenas do tamanho da imagem, dado que o filtro é calculado percorrendo o array \texttt{cumSum} 
que tem o mesmo tamanho da imagem.
\par
A função \texttt{ImageBlur} é definida da seguinte forma:

\begingroup
\begin{lstlisting}[language=C]
  void ImageBlur(Image img, int dx, int dy) {
    assert(img != NULL);
    assert(dx >= 0);
    assert(dy >= 0);

    int width = img->width;
    int height = img->height;

    // Create an array to store cumulative sums
    double** cumSum = (double**)malloc(height * sizeof(double*));
    for (int i = 0; i < height; i++) {
        cumSum[i] = (double*)malloc(width * sizeof(double));
    }

    // Calculate cumulative sums
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            ADDS += 1;

            // Get the value of the current pixel
            cumSum[i][j] = ImageGetPixel(img, j, i);

            // Add the values of the pixels above and to the left
            if (j > 0) {
                cumSum[i][j] += cumSum[i][j - 1];
            }

            if (i > 0) {
                cumSum[i][j] += cumSum[i - 1][j];
            }

            // Subtract the intersection to avoid double addition
            if (i > 0 && j > 0) {
                cumSum[i][j] -= cumSum[i - 1][j - 1];
            }
        }
    }

    // Apply the filter
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            ADDS += 1;

            // Calculate the coordinates of the rectangle
            int iMin = (i - dy > 0) ? i - dy : 0;
            int iMax = (i + dy < height - 1) ? i + dy : height - 1;
            int jMin = (j - dx > 0) ? j - dx : 0;
            int jMax = (j + dx < width - 1) ? j + dx : width - 1;

            // Calculate the area of the rectangle
            int area = (iMax - iMin + 1) * (jMax - jMin + 1);

            // Calculate the sum of the pixels inside the rectangle
            double sum = cumSum[iMax][jMax];

            // Subtract the values of the pixels outside the rectangle
            if (iMin > 0) {
                sum -= cumSum[iMin - 1][jMax];
            }
            if (jMin > 0) {
                sum -= cumSum[iMax][jMin - 1];
            }

            // Add the value of the intersection to avoid double subtraction
            if (iMin > 0 && jMin > 0) {
                sum += cumSum[iMin - 1][jMin - 1];
            }

            // Calculate the mean and round it
            uint8 roundedValue = (uint8)(round(sum / area));
            ImageSetPixel(img, j, i, roundedValue);
        }
    }

    // Free the allocated memory
    for (int i = 0; i < height; i++) {
        free(cumSum[i]);
    }
    free(cumSum);
    
}
\end{lstlisting}
\endgroup

\subsection{Análise Formal da Complexidade}

\subsubsection{Complexidade Temporal}

\subsubsection{Inicialização da Matriz de Soma Cumulativa}
A inicialização da matriz de soma cumulativa tem uma complexidade de \(O(n \cdot m)\), pois itera por cada pixel da imagem,
dentro de dois ciclos aninhados, sendo \(n\) e \(m\) a altura e largura da imagem, respetivamente.

\subsubsection{Aplicação do Filtro}
A aplicação do filtro tem uma complexidade de \(O(n \cdot m)\), pois itera por cada posição da imagem, da mesma forma que a inicialização 
da matriz de soma cumulativa. Logo, a complexidade temporal da função \texttt{ImageBlur} é \(O(n \cdot m)\).
\par
\subsubsection{}
Portanto, a complexidade temporal global da função \texttt{ImageBlur} é \(O(n \cdot m)\), considerando que o fator que contribui mais para a complexidade 
é a dimensão da imagem. Isto quer dizer que o desempenho da função \texttt{ImageBlur} é linear em relação à dimensão da imagem.


\subsubsection{Complexidade Espacial}

\subsubsection{Matriz de Soma Cumulativa}
A matriz de soma cumulativa tem uma complexidade de \(O(n \cdot m)\), pois aloca memória para uma matriz de \(n\) linhas e \(m\) colunas, 
dando uma complexidade espacial de \(O(n \cdot m)\), sendo \(n\) e \(m\) a altura e largura da imagem, respetivamente.

\subsubsection{Outras Variáveis}
As outras variáveis e índices de ciclo têm um espaço constante e não escalam com o tamanho da imagem, não contribuindo para o escalamento da 
complexidade espacial.
\par
\subsubsection*{}
Em suma, a complexidade espacial global da função \texttt{ImageBlur} é \(O(n \cdot m)\).

\subsection{Testes Experimentais}

\subsection*{Image: pgm/small/bird\_256x256.pgm}

\subsubsection*{Operações BLUR}
\begin{tabular}{ccccc}
\toprule
\textbf{BLUR level} & \textbf{time} & \textbf{caltime} & \textbf{memops} & \textbf{adds} \\
\midrule
0 & 0.001066 & 0.001617 & 196608 & 131072 \\
1 & 0.001286 & 0.001950 & 196608 & 131072 \\
5 & 0.003052 & 0.004629 & 196608 & 131072 \\
10 & 0.003037 & 0.004607 & 196608 & 131072 \\
100 & 0.002946 & 0.004468 & 196608 & 131072 \\
\bottomrule
\end{tabular}

\subsection*{Image: pgm/medium/mandrill\_512x512.pgm}

\subsubsection*{Operações BLUR}
\begin{tabular}{ccccc}
\toprule
\textbf{BLUR level} & \textbf{time} & \textbf{caltime} & \textbf{memops} & \textbf{adds} \\
\midrule
0 & 0.006272 & 0.009305 & 786432 & 524288 \\
1 & 0.004705 & 0.006980 & 786432 & 524288 \\
5 & 0.003729 & 0.005533 & 786432 & 524288 \\
10 & 0.003688 & 0.005472 & 786432 & 524288 \\
100 & 0.003639 & 0.005399 & 786432 & 524288 \\
\bottomrule
\end{tabular}

\subsection*{Image: pgm/large/einstein\_940x940.pgm}

\subsubsection*{Operações BLUR}
\begin{tabular}{ccccc}
\toprule
\textbf{BLUR level} & \textbf{time} & \textbf{caltime} & \textbf{memops} & \textbf{adds} \\
\midrule
0 & 0.012961 & 0.019409 & 2650800 & 1767200 \\
1 & 0.015503 & 0.023216 & 2650800 & 1767200 \\
5 & 0.017395 & 0.026050 & 2650800 & 1767200 \\
10 & 0.012389 & 0.018554 & 2650800 & 1767200 \\
100 & 0.012489 & 0.018703 & 2650800 & 1767200 \\
\bottomrule
\end{tabular}

\subsection*{Image: pgm/large/ireland\_03\_1600x1200.pgm}

\subsubsection*{Operações BLUR}
\begin{tabular}{ccccc}
\toprule
\textbf{BLUR level} & \textbf{time} & \textbf{caltime} & \textbf{memops} & \textbf{adds} \\
\midrule
0 & 0.034541 & 0.052110 & 5760000 & 3840000 \\
1 & 0.035604 & 0.053714 & 5760000 & 3840000 \\
5 & 0.034155 & 0.051527 & 5760000 & 3840000 \\
10 & 0.030031 & 0.045306 & 5760000 & 3840000 \\
100 & 0.029878 & 0.045076 & 5760000 & 3840000 \\
\bottomrule
\end{tabular}

\subsection{Conclusões}

Conseguimos confirmar que se verifica experimentalmente, aquilo que se esperava pela análise formal da complexidade. O número a complexidade, dada por \(adds\), escala linearmente com o tamanho da imagem. Conseguimos determinar \(adds\) pela multiplicação de \(image\char`_height\) por \(image\char`_length\), por exemplo para a imagem \texttt{instein\char`_940x940.pgm} temos \texttt{$adds = 940*940 = 1767200$}.
\par
Verifica-se também que a intensidade de \(blur\), não impacta em nada o desempenho da função, sendo igual o número de \(memops\) e \(adds\) para todos os níveis de intensidade.


\section{Análise da complexidade da função ImageWorstBlur}

\subsection{Apresentação}
Para aprensentar uma função menos eficiente, criamos a função \texttt{ImageWorstBlur}, onde o filtro é calculado sem utilizar a matriz auxiliar,
calculando a média dos valores do filtro a cada iteração, percorrendo a imagem original e o filtro.
\par
A função \texttt{ImageWorstBlur} é definida da seguinte forma:

\begingroup
\begin{lstlisting}[language=C]
void WorseImageBlur(Image img, int dx, int dy) {
  assert(img != NULL);
  assert(dx >= 0);
  assert(dy >= 0);
  
  // Create a copy of the image
  int pixelsize = img->width * img->height;
  Image img_copy = ImageCreate(img->width, img->height, img->maxval);
  img_copy->pixel = (uint8*)malloc(pixelsize * sizeof(uint8));
  memcpy(img_copy->pixel, img->pixel, pixelsize * sizeof(uint8));
  
  // Apply the filter
  for (int i = 0; i < img->height; i++) {
      for (int j = 0; j < img->width; j++) {
          double sum = 0.0;
          int count = 0;
          // Calculate the coordinates of the rectangle
          for (int k = i - dy; k <= i + dy; k++) {
              for (int l = j - dx; l <= j + dx; l++) {
                  ADDS += 1;
                  // Check if the pixel is inside the image
                  if (ImageValidPos(img, l, k)) {
                    // Add the value of the pixel to the sum
                    sum += ImageGetPixel(img_copy, l, k);
                    count++;
                  }
              }
          }

          // Calculate the mean and round it
          uint8 roundedValue = (uint8)(round(sum / count));
          ImageSetPixel(img, j, i, roundedValue);
      }
  }
  // Free the allocated memory
  free(img_copy->pixel);
  free(img_copy);
}
\end{lstlisting}
\endgroup

\subsection{Análise Formal da Complexidade}

\subsubsection{Complexidade Temporal}

\subsubsection{Cópia da Imagem}
A cópia da imagem tem uma complexidade de \(O(n \cdot m)\), onde \(n\) e \(m\) são a altura e largura da imagem, respetivamente.

\subsubsection{Aplicação do Filtro}
A aplicação do filtro tem uma complexidade de \(O(n \cdot m \cdot (2 \cdot dy + 1) \cdot (2 \cdot dx + 1))\), 
onde \(n\) e \(m\) são a altura e largura da imagem, respetivamente, 
\(dx\) e \(dy\) são a largura e altura do filtro, respetivamente.
\par
O loop externo itera sobre a altura da imagem (\(n\)) e o loop interno itera sobre a largura da imagem (\(m\)).
\par
Para cada pixel, há um loop adicional que itera sobre uma região retangular de tamanho \((2 \cdot dy + 1) \cdot (2 \cdot dx + 1)\).
\par
Portanto, a complexidade temporal geral da função \texttt{WorseImageBlur} é \(O(n \cdot m \cdot (2 \cdot dy + 1) \cdot (2 \cdot dx + 1))\), 
qe aumenta quadraticamente com o tamanho da imagem e do filtro.


\subsubsection{Complexidade Espacial}

\subsubsection{Cópia da Imagem}
A complexidade espacial para copiar a imagem é \(O(n \cdot m)\) para a imagem copiada.

\subsubsection{Outras Variáveis}
O espaço necessário para outras variáveis e índices de loop é constante e não escala com o tamanho de entrada.

\subsubsection{}
Em suma, a complexidade espacial da função \texttt{WorseImageBlur} é \(O(n \cdot m)\), que aumenta linearmente com o tamanho da imagem.

\subsubsection{}
Em suma, a complexidade temporal da função \texttt{WorseImageBlur} é \(O(n \cdot m \cdot (2 \cdot dy + 1) \cdot (2 \cdot dx + 1))\),
e a complexidade espacial é \(O(n \cdot m)\). A complexidade temporal dessa função é significativamente maior do que a da função original \texttt{ImageBlur},
especialmente devido aos loops aninhados para a cópia e à região considerada para a aplicação do filtro.


\subsection{Testes Experimentais}


\subsection{Conclusões}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\printbibliography

\end{document}
